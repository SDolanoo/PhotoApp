package com.example.photoapp.database.data

import android.util.Log
import androidx.lifecycle.LiveData
import androidx.room.Dao
import androidx.room.Delete
import androidx.room.Insert
import androidx.room.Query
import androidx.room.Transaction
import androidx.room.Update
import java.util.Calendar
import java.util.Date

// DAO dla Uzytkownik
@Dao
interface UzytkownikDao {
    @Query("SELECT * FROM Uzytkownik")
    fun getAll(): LiveData<List<Uzytkownik>>

    @Query("SELECT * FROM Uzytkownik WHERE id = :id")
    fun getById(id: Int): Uzytkownik?

    @Insert
    fun insert(uzytkownik: Uzytkownik): Long

    @Update
    fun update(uzytkownik: Uzytkownik)

    @Delete
    fun delete(uzytkownik: Uzytkownik)

    @Transaction
    fun addUser(login: String, password: String, email: String) {
        val newUser = Uzytkownik(
            login = login,
            password = password,
            email = email
        )
        val id = insert(newUser)
        Log.i("Dolan", "\"Użytkownik '$login' został dodany do bazy danych. z ID ${id}\"")

    }
}

// DAO dla Odbiorca
@Dao
interface OdbiorcaDao {
    @Query("SELECT * FROM Odbiorca")
    fun getAll(): List<Odbiorca>

    @Insert
    fun insert(odbiorca: Odbiorca): Long

    @Query("SELECT * FROM odbiorca WHERE nip = :nip LIMIT 1")
    fun getOdbiorcaByNip(nip: String): Odbiorca?

    @Transaction
    fun addOrGetOdbiorca(nazwa: String, nip: String, adres: String): Odbiorca {
        var odbiorca = getOdbiorcaByNip(nip)
        if (odbiorca == null) {
            odbiorca = Odbiorca(
                nazwa = nazwa,
                nip = nip,
                adres = adres
            )
            val id = insert(odbiorca).toInt()
            odbiorca.id = id

        }
        Log.i("Dolan", "Odbiorca z ID: ${odbiorca.id} i nip ${odbiorca.nip}")

        return odbiorca
    }

    @Update
    fun update(odbiorca: Odbiorca)

    @Delete
    fun delete(odbiorca: Odbiorca)
}

// DAO dla Sprzedawca
@Dao
interface SprzedawcaDao {
    @Query("SELECT * FROM Sprzedawca")
    fun getAll(): List<Sprzedawca>

    @Query("SELECT * FROM Sprzedawca WHERE id = :id")
    fun getById(id: Int): Sprzedawca?

    @Insert
    fun insert(sprzedawca: Sprzedawca): Long

    @Query("SELECT * FROM sprzedawca WHERE nip = :nip LIMIT 1")
    fun getSprzedawcaByNip(nip: String): Sprzedawca?

    @Transaction
    fun addOrGetSprzedawca(nazwa: String, nip: String, adres: String): Sprzedawca {
        var sprzedawca = getSprzedawcaByNip(nip)
        if (sprzedawca == null) {
            sprzedawca = Sprzedawca(
                nazwa = nazwa,
                nip = nip,
                adres = adres
            )
            val id = insert(sprzedawca).toInt()
            sprzedawca.id = id
        }
        Log.i("Dolan", "Sprzedawca z ID: ${sprzedawca.id} i nip ${sprzedawca.nip}")

        return sprzedawca
    }

    @Update
    fun update(sprzedawca: Sprzedawca)

    @Delete
    fun delete(sprzedawca: Sprzedawca)
}

// DAO dla Paragon
@Dao
interface ParagonDao {
    @Query("SELECT * FROM Paragon ORDER BY dataZakupu DESC")
    fun getAllLiveParagony(): LiveData<List<Paragon>>

    @Query("SELECT * FROM Paragon")
    fun getAll(): List<Paragon>

    @Query("SELECT * FROM Paragon WHERE id = :id")
    fun getById(id: Int): Paragon?

    @Insert
    fun insertParagon(paragon: Paragon): Long

    @Transaction
    fun addRecipe(
        uzytkownikId: Int,
        recipeDate: List<Int>,
        nazwaSklepu: String,
        kwotaCalkowita: Double,
        produkty: List<Map<String, Any>>,
        produktParagonDao: ProduktParagonDao
    ) {
        val paragon = Paragon(
            uzytkownikId = uzytkownikId,
            dataZakupu = Calendar.getInstance().apply {
                set(recipeDate[0], recipeDate[1] - 1, recipeDate[2])
            }.time,
            nazwaSklepu = nazwaSklepu,
            kwotaCalkowita = kwotaCalkowita
        )

        // Wstawienie paragonu i pobranie ID (autogenerated ID)
        val paragonId = insertParagon(paragon).toInt()

        // Dodanie produktów do paragonu
        produktParagonDao.addProduct(paragonId, produkty)

        Log.i("Dolan", "\"Paragon został dodany do bazy z ID: $paragonId\"")
    }

    @Transaction
    fun addTestRecipe() {
        // Pobierz użytkowników z bazy danych
        val uzytkownikID = 1

        // Przykładowe kwoty
        val testoweKwoty = listOf(100.50, 200.75, 50.30, 80.99, 120.00, 300.00, 15.75, 60.45, 500.20, 250.10)

        // Dodaj 10 testowych paragonów
        for (i in 0 until 20) {
            val paragon = Paragon(
                uzytkownikId = uzytkownikID,
                dataZakupu = Calendar.getInstance().apply {
                    set(2024, i, i + 5) // Ustalona data testowa (YYYY, MM, DD)
                }.time,
                nazwaSklepu = "Sklep $i",
                kwotaCalkowita = testoweKwoty.random()
            )
            insertParagon(paragon)
        }

        Log.i("Dolan", "Dodano 10 testowych paragonów.")
    }



    @Query("""
    SELECT * FROM Paragon 
    WHERE (:startDate IS NULL OR dataZakupu >= :startDate) 
    AND (:endDate IS NULL OR dataZakupu <= :endDate) 
    AND (:minPrice IS NULL OR kwotaCalkowita >= :minPrice) 
    AND (:maxPrice IS NULL OR kwotaCalkowita <= :maxPrice)
    ORDER BY dataZakupu DESC
""")
    fun getFilteredParagony(
        startDate: Date?,
        endDate: Date?,
        minPrice: Double?,
        maxPrice: Double?
    ): List<Paragon>


    @Update
    fun update(paragon: Paragon)

    @Delete
    fun delete(paragon: Paragon)
}

// DAO dla ProduktParagon
@Dao
interface ProduktParagonDao {
    @Query("SELECT * FROM ProduktParagon")
    fun getAll(): List<ProduktParagon>

    @Query("SELECT * FROM ProduktParagon WHERE paragonId = :paragonId")
    fun getProductByParagonId(paragonId: Int): List<ProduktParagon>

    @Insert
    fun insert(produktParagon: ProduktParagon)

    @Transaction
    fun addProduct(paragonId: Int, produkty: List<Map<String, Any>>) {
        for (produkt in produkty) {
            val nazwaProduktu = produkt["nazwa_produktu"] as String
            val cenaSuma = (produkt["cena_suma"] as Double)
            val ilosc = (produkt["ilosc"] as Int)

            val produktParagon = ProduktParagon(
                paragonId = paragonId,
                nazwaProduktu = nazwaProduktu,
                cenaSuma = cenaSuma,
                ilosc = ilosc,
                kategoriaId = null
            )
            insert(produktParagon)
        }
        Log.i("Dolan", "Produkty zostały dodane do paragonu o ID: $paragonId")
    }

    @Transaction
    fun addTestRecipeProducts(paragonDao: ParagonDao) {
        val paragony: List<Paragon> = paragonDao.getAll()
        if (paragony.isEmpty()) {
            Log.e("Dolan", "Paragony is Empty")
            throw IllegalArgumentException("Paragony is Empty")
        }
        data class TempProdukt(val nazwa_produktu: String, val cena_suma: Double)

        val produktyTestowe = listOf(
            TempProdukt("Mleko", 3.50),
            TempProdukt("Chleb", 2.80),
            TempProdukt("Masło", 7.50),
            TempProdukt("Ser", 10.99),
            TempProdukt("Kawa", 25.00),
            TempProdukt("Cukier", 5.00),
            TempProdukt("Czekolada", 8.50),
            TempProdukt("Woda mineralna", 2.00),
            TempProdukt("Sok pomarańczowy", 4.50),
            TempProdukt("Makaron", 6.00)
        )

        paragony.forEach { paragon ->
            val numberOfProducts = kotlin.random.Random.nextInt(1, 6)
            val ilosc: Int = kotlin.random.Random.nextInt(1, 5)
            repeat(numberOfProducts) {
                val product = produktyTestowe.random()
                val productParagon = ProduktParagon(
                    paragonId = paragon.id,
                    kategoriaId = null,
                    nazwaProduktu = product.nazwa_produktu,
                    ilosc = ilosc,
                    cenaSuma = (product.cena_suma * ilosc),
                )
                insert(productParagon)
            }
        }
    }

    @Update
    fun update(produktParagon: ProduktParagon)

    @Delete
    fun delete(produktParagon: ProduktParagon)
}

// DAO dla Faktura
@Dao
interface FakturaDao {
    @Query("SELECT * FROM Faktura ORDER BY dataSprzedazy DESC")
    fun getAllLiveFaktury(): LiveData<List<Faktura>>

    @Query("SELECT * FROM Faktura WHERE id = :id")
    fun getById(id: Int): Faktura?

    @Insert
    fun insertFaktura(faktura: Faktura): Long

    @Transaction
    fun addInvoice(
        uzytkownikId: Int,
        odbiorcaData: Map<String, String>,
        sprzedawcaData: Map<String, String>,
        fakturaData: Map<String, Any>,
        produkty: List<Map<String, Any>>,
        odbiorcaDao: OdbiorcaDao,
        sprzedawcaDao: SprzedawcaDao,
        produktFakturaDao: ProduktFakturaDao
    ) {
        // Dodaj odbiorcę lub pobierz istniejącego
        val odbiorca = odbiorcaDao.addOrGetOdbiorca(
            nazwa = odbiorcaData["nazwa"]!!,
            nip = odbiorcaData["nip"]!!,
            adres = odbiorcaData["adres"]!!
        )

        // Dodaj sprzedawcę lub pobierz istniejącego
        val sprzedawca = sprzedawcaDao.addOrGetSprzedawca(
            nazwa = sprzedawcaData["nazwa"]!!,
            nip = sprzedawcaData["nip"]!!,
            adres = sprzedawcaData["adres"]!!
        )

        // Dodaj fakturę
        val faktura = Faktura(
            uzytkownikId = uzytkownikId,
            odbiorcaId = odbiorca.id,
            sprzedawcaId = sprzedawca.id,
            numerFaktury = fakturaData["numer_faktury"] as String,
            nrRachunkuBankowego = fakturaData["nr_rachunku_bankowego"] as String?,
            dataWystawienia = fakturaData["data_wystawienia"] as Date,
            dataSprzedazy = fakturaData["data_sprzedaży"] as Date?,
            razemNetto = fakturaData["razem_netto"] as String,
            razemStawka = fakturaData["razem_stawka"] as String,
            razemPodatek = fakturaData["razem_podatek"] as String,
            razemBrutto = fakturaData["razem_brutto"] as String,
            waluta = fakturaData["waluta"] as String,
            formaPlatnosci = fakturaData["forma_płatnosci"] as String
        )

        val fakturaId = insertFaktura(faktura).toInt()

        // Dodaj produkty do faktury
        produktFakturaDao.addProduct(fakturaId, produkty)

        println("Faktura została dodana z ID: $fakturaId")
    }

    // ITS BETTER TO MAKE ONE COMPLICATED THAN 534534 FUNCTIONS
    @Query(""" 
    SELECT * FROM Faktura 
    WHERE (:startDate IS NULL OR 
          (:filterDate = 'dataWystawienia' AND dataWystawienia >= :startDate) OR 
          (:filterDate = 'dataSprzedazy' AND dataSprzedazy >= :startDate)) 
    AND (:endDate IS NULL OR 
          (:filterDate = 'dataWystawienia' AND dataWystawienia <= :endDate) OR 
          (:filterDate = 'dataSprzedazy' AND dataSprzedazy <= :endDate)) 
    AND (:minPrice IS NULL OR 
        (:filterPrice = 'brutto' AND razemBrutto >= :minPrice) OR
        (:filterPrice = 'netto' AND razemNetto >= :minPrice))
    AND (:maxPrice IS NULL OR
        (:filterPrice = 'brutto' AND razemBrutto >= :maxPrice) OR
        (:filterPrice = 'netto' AND razemNetto >= :maxPrice))
    ORDER BY 
        CASE :filterDate
            WHEN 'dataWystawienia' THEN dataWystawienia 
            WHEN 'dataSprzedaży' THEN dataSprzedazy 
        END DESC
""")
    fun getFilteredFaktury(
        startDate: Date?,
        endDate: Date?,
        minPrice: Double?,
        maxPrice: Double?,
        filterDate: String, // Możliwe wartości: "dataWystawienia" lub "dataSprzedazy"
        filterPrice: String,
    ): List<Faktura>

    @Update
    fun update(faktura: Faktura)

    @Delete
    fun delete(faktura: Faktura)
}

// DAO dla ProduktFaktura
@Dao
interface ProduktFakturaDao {
    @Query("SELECT * FROM ProduktFaktura")
    fun getAll(): List<ProduktFaktura>

    @Query("SELECT * FROM ProduktFaktura WHERE fakturaId = :fakturaId")
    fun getProductByFakturaId(fakturaId: Int): List<ProduktFaktura>

    @Insert
    fun insert(produktFaktura: ProduktFaktura)

    @Transaction
    fun addProduct(idFaktury: Int, produkty: List<Map<String, Any>>) {
        for (produkt in produkty) {
            val nazwaProduktu = produkt["nazwa_produktu"] as String
            val jednostkaMiary = produkt["jednostka_miary"] as String?
            val ilosc = (produkt["ilosc"] as Double).toString()
            val wartoscNetto = produkt["wartosc_netto"] as String
            val stawkaVat = produkt["stawka_vat"] as String
            val podatekVat = produkt["podatek_vat"] as String
            val brutto = produkt["brutto"] as String

            val produktFaktura = ProduktFaktura(
                fakturaId = idFaktury,
                nazwaProduktu = nazwaProduktu,
                jednostkaMiary = jednostkaMiary,
                ilosc = ilosc,
                wartoscNetto = wartoscNetto,
                stawkaVat = stawkaVat,
                podatekVat = podatekVat,
                brutto = brutto
            )
            insert(produktFaktura)
        }
        println("Produkty zostały dodane do faktury o ID: $idFaktury")
    }

    @Update
    fun update(produktFaktura: ProduktFaktura)

    @Delete
    fun delete(produktFaktura: ProduktFaktura)
}

// DAO dla Kategoria
@Dao
interface KategoriaDao {
    @Query("SELECT * FROM Kategoria")
    fun getAll(): List<Kategoria>

    @Query("SELECT * FROM Kategoria WHERE id = :id")
    fun getById(id: Int): Kategoria?

    @Insert
    fun insert(kategoria: Kategoria)

    @Update
    fun update(kategoria: Kategoria)

    @Delete
    fun delete(kategoria: Kategoria)
}

@Dao
interface RaportFiskalnyDao {

    @Query("SELECT * FROM RaportFiskalny ORDER BY dataDodania")
    fun getAllLiveRaportFiskalny(): LiveData<List<RaportFiskalny>>

    @Query("SELECT * FROM RaportFiskalny")
    fun getAll(): List<RaportFiskalny>

    @Insert
    fun insert(raportFiskalny: RaportFiskalny): Long

    @Update
    fun update(raportFiskalny: RaportFiskalny)

    @Delete
    fun delete(raportFiskalny: RaportFiskalny)
}

@Dao
interface ProduktRaportFiskalnyDao {
    @Query("SELECT * FROM ProduktRaportFiskalny")
    fun getAllLive(): LiveData<List<ProduktRaportFiskalny>>

    @Query("SELECT * FROM ProduktRaportFiskalny WHERE raportFiskalnyId = :raportFiskalnyId ORDER BY nrPLU ASC")
    fun getProductForRaportFiskalny(raportFiskalnyId: Int): List<ProduktRaportFiskalny>

    @Insert
    fun insert(produktRaportFiskalny: ProduktRaportFiskalny): Long

    @Update
    fun update(produktRaportFiskalny: ProduktRaportFiskalny)

    @Delete
    fun delete(produktRaportFiskalny: ProduktRaportFiskalny)
}
